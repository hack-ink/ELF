[service]
admin_bind = "127.0.0.1:51891"
http_bind  = "127.0.0.1:51892"
log_level  = "info"
mcp_bind   = "127.0.0.1:51893"

[storage.postgres]
dsn            = "postgres://postgres:postgres@127.0.0.1:5432/elf"
pool_max_conns = 10

[storage.qdrant]
collection = "mem_notes_v2"
url        = "http://127.0.0.1:6334"
vector_dim = 4_096

[mcp]
agent_id     = "local-agent"
project_id   = "local-project"
read_profile = "private_plus_project"
tenant_id    = "local-tenant"

[providers.embedding]
api_base        = "https://provider.example"
api_key         = "REPLACE_ME"
default_headers = {}
dimensions      = 4_096
model           = "embedding-model"
path            = "/embeddings"
provider_id     = "provider-id"
timeout_ms      = 20_000

[providers.rerank]
api_base        = "https://provider.example"
api_key         = "REPLACE_ME"
default_headers = {}
model           = "rerank-model"
path            = "/rerank"
provider_id     = "provider-id"
timeout_ms      = 20_000

[providers.llm_extractor]
api_base        = "https://provider.example"
api_key         = "REPLACE_ME"
default_headers = {}
model           = "llm-model"
path            = "/chat/completions"
provider_id     = "provider-id"
temperature     = 0.1
timeout_ms      = 30_000

[scopes]
allowed = ["agent_private", "org_shared", "project_shared"]

[scopes.read_profiles]
all_scopes           = ["agent_private", "org_shared", "project_shared"]
private_only         = ["agent_private"]
private_plus_project = ["agent_private", "project_shared"]

[scopes.precedence]
agent_private  = 30
org_shared     = 10
project_shared = 20

[scopes.write_allowed]
agent_private  = true
org_shared     = true
project_shared = true

[memory]
candidate_k             = 60
dup_sim_threshold       = 0.92
max_note_chars          = 240
max_notes_per_add_event = 3
top_k                   = 12
update_sim_threshold    = 0.85

[chunking]
enabled        = true
max_tokens     = 512
overlap_tokens = 128
tokenizer_repo = "REPLACE_ME"

[search.expansion]
include_original = true
max_queries      = 4
mode             = "dynamic"

[search.dynamic]
min_candidates = 10
min_top_score  = 0.12

[search.prefilter]
max_candidates = 0

[search.cache]
enabled            = true
expansion_ttl_days = 7
max_payload_bytes  = 262_144
rerank_ttl_days    = 7

[search.explain]
candidate_retention_days = 2
capture_candidates       = false
retention_days           = 7
write_mode               = "outbox"

[ranking]
recency_tau_days   = 60
tie_breaker_weight = 0.1

[ranking.deterministic]
enabled = false

[ranking.deterministic.lexical]
enabled         = false
max_query_terms = 16
max_text_terms  = 1024
min_ratio       = 0.3
weight          = 0.05

[ranking.deterministic.hits]
enabled           = false
half_saturation   = 8.0
last_hit_tau_days = 14.0
weight            = 0.05

[ranking.deterministic.decay]
enabled  = false
tau_days = 30.0
weight   = 0.05

[ranking.blend]
enabled                 = true
rerank_normalization    = "rank"
retrieval_normalization = "rank"

[[ranking.blend.segments]]
max_retrieval_rank = 3
retrieval_weight   = 0.8

[[ranking.blend.segments]]
max_retrieval_rank = 10
retrieval_weight   = 0.5

[[ranking.blend.segments]]
max_retrieval_rank = 1_000_000
retrieval_weight   = 0.2

[ranking.diversity]
enabled       = true
max_skips     = 64
mmr_lambda    = 0.7
sim_threshold = 0.88

[ranking.retrieval_sources]
fusion_priority           = 1
fusion_weight             = 1.0
structured_field_priority = 0
structured_field_weight   = 1.0

[lifecycle.ttl_days]
constraint = 0
decision   = 0
fact       = 180
plan       = 14
preference = 0
profile    = 0

[lifecycle]
purge_deleted_after_days    = 30
purge_deprecated_after_days = 180

[security]
auth_keys                = []
auth_mode                = "off"
bind_localhost_only      = true
evidence_max_quote_chars = 320
evidence_max_quotes      = 2
evidence_min_quotes      = 1
redact_secrets_on_write  = true
reject_cjk               = true

# Explicit auth mode:
# - "off": no auth checks; only safe for local loopback binds.
# - "static_keys": require Authorization: Bearer <token> and derive context from keys.
#
# When auth_mode is "static_keys", every request context is derived from the matched key.
# Caller-provided context headers are ignored/overridden.
# [[security.auth_keys]]
# token_id     = "dev-client"
# token        = "replace-with-opaque-secret"
# tenant_id    = "t"
# project_id   = "p"
# agent_id     = "a"
# read_profile = "private_plus_project"
# admin        = false

[context]
# Optional. Context metadata used to disambiguate retrieval across projects and scopes.
#
# project_descriptions keys:
# - "<tenant_id>:<project_id>" (recommended)
# - "<project_id>" (fallback)
# Optional. Additive score boost applied when query tokens match a scope description.
# Set to 0.0 to disable.
# Must be a finite number in the range 0.0-1.0. When greater than zero, scope_descriptions must be present.
scope_boost_weight = 0.05

[context.project_descriptions]
"t:p" = "Example project context description."

[context.scope_descriptions]
agent_private  = "Personal notes for a single agent."
org_shared     = "Organization-wide policies and shared operating context."
project_shared = "Project-specific shared notes and technical context."
